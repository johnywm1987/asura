#include "stdafx.h"
#include "HPro.h"

#include "SimpleProcessAPI.h"
#include "MiniVersion.h"
#include <TlHelp32.h>
#include <algorithm>
#include "CompByte.h"
#include "DebugSet.h"
#include "SUBPATH.h"
#include "GetWinVer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define STREAM_OFFSET	4125
#define STREAM_SIZE		33

TCHAR szWindowText[255] = ""; // 윈도우 텍스트를 저장하기 위한 배열

/*dmk14 otarapa anti cheat*/
HDump mDumps[] = {	
	{0x4017D0, {0x55, 0x8b, 0xec, 0x6a, 0xff, 0x68, 0x08, 0x51}}, // Mu Window (testes)
	{0xD1A35C, {0xe9, 0x70, 0xfe, 0xff, 0xff, 0xb8, 0x08, 0xce}}, // DARKTERRO
	{0x40BD6E, {0xFF, 0x25, 0x00, 0x20, 0x40, 0x00, 0x00, 0x00}}, // #### Privado #### AutoPot ####  With ASLR active
	{0x4A9BF6, {0xe8, 0x0E, 0xAE, 0x00, 0x00, 0xE9, 0x79, 0xFE}}, //Process Explorer Portable (testes)
	{0x8BBBC0, {0x6C, 0x05, 0xE0, 0xDB, 0x8B, 0x00, 0x00, 0xE8}}, //Cheat Engine 6.4 (testes)
	{0x401000, {0xEB, 0x10, 0x66, 0x62, 0x3A, 0x43, 0x2B, 0x2B}}, //OllyDbg 1.10
	{0x407973, {0xF3, 0xA5, 0x8B, 0xCA, 0x83, 0xE1, 0x03, 0xF3}}, //OllyDbg 2.00
	{0x610649, {0xBA, 0x04, 0x08, 0x61, 0x00, 0xE8, 0x65, 0x4D}}, //Cheat Engine 5.6.1
	{0x435217, {0xFF, 0x15, 0xC4, 0xD6, 0x47, 0x00, 0x8B, 0xF0}}, //Shotbot
	{0x4351E6, {0x8B, 0x15, 0x64, 0xF3, 0x49, 0x00, 0x6A, 0x00}}, //Novo Shotbot
	{0x4039e3, {0x81, 0xEC, 0xD4, 0x02, 0x00, 0x00, 0x53, 0x55}}, //Process hacker portable
	{0x44E08C, {0x64, 0x89, 0x25, 0x00, 0x00, 0x00, 0x00, 0x83}}, //WPE Pro
	{0x4307BE, {0x75, 0x0A, 0x6A, 0x1C, 0xE8, 0x49, 0x01, 0x00}}, //WPE Pro
	{0x4851C2, {0x75, 0x1C, 0x53, 0x8B, 0xCE, 0xFF, 0x75, 0xE4}}, //WPe Pro
	{0x44397B, {0x75, 0x07, 0x8B, 0xCF, 0xE8, 0xF8, 0xF2, 0xFF}}, //WPe Pro
	{0x401468, {0x74, 0x03, 0x8B, 0x6D, 0x04, 0x8B, 0x97, 0x30}}, //WPe Pro
	{0x574EEC, {0xE8, 0x8B, 0xEA, 0xF1, 0xFF, 0x8D, 0x45, 0xEC}}, //Cheat Engine
	{0x4CBD70, {0x8D, 0x85, 0x7C, 0xFE, 0xFF, 0xFF, 0xBA, 0x03}}, //Cheat Engine
	{0x591FC0, {0xE8, 0x07, 0x23, 0xF0, 0xFF, 0x8D, 0x45, 0xEC}}, //Cheat Engine
	{0x5839E7, {0x8D, 0x45, 0xB0, 0x50, 0x6A, 0x08, 0x8D, 0x85}}, //Cheat Engine
	{0x4CBE2B, {0x8D, 0x55, 0xF0, 0xB9, 0x04, 0x00, 0x00, 0x00}}, //Cheat Engine
	{0x5CF354, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xEC, 0x53, 0x33}}, //Cheat Engine
	{0x5CF440, {0xE8, 0x37, 0xA3, 0xFC, 0xFF, 0xE8, 0x8E, 0x96}}, //Chear Engine
	{0x5CF43D, {0x8D, 0x45, 0xEC, 0xE8, 0x37, 0xA3, 0xFC, 0xFF}}, //Cheat Engine
	{0x5FECF4, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xEC, 0x53, 0x33}}, //Cheat Engine
	{0x6105D4, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xE8, 0x53, 0x33}}, //Cheat Engine
	{0x5FED5B, {0xE8, 0x10, 0xC3, 0xE9, 0xFF, 0x8B, 0x0D, 0x64}}, //Cheat Engine
	{0x434460, {0xc6, 0x05, 0x60, 0xf0, 0x43, 0x00, 0x00, 0xe8}}, //Cheat Engine
	{0x5674D4, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xEC, 0x53, 0x33}}, //Cheat Engine
	{0x5AA16C, {0xE8, 0x13, 0x40, 0xFF, 0xFF, 0xE8, 0x86, 0x2C}}, //Cheat Engine
	{0x591F94, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xEC, 0x53, 0x33}}, //Cheat Engine
	{0x5CF354, {0x78, 0xAA, 0x4A, 0x00, 0x48, 0xAA, 0x4A, 0x00}}, //Cheat Engine
	{0x606140, {0x8C, 0x79, 0x60, 0x00, 0xE0, 0xA8, 0x60, 0x00}}, //Cheat Engine
	{0x574EC0, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xEC, 0x53, 0x33}}, //Cheat Engine
	{0x40C484, {0x8B, 0x45, 0x08, 0xFF, 0x70, 0x0C, 0xFF, 0x70}}, //Cheat Engine
	{0x408771, {0xEB, 0x07, 0x8B, 0x45, 0x0C, 0x33, 0xD2, 0x89}}, //Cheat Engine	

	{0x434D90, {0xF8, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x8B, 0x55}}, //Cheat Engine 6.4
	{0x8BBBC0, {0xC6, 0x05, 0xE0, 0xDB, 0x8B, 0x00, 0x00, 0xE8}}, //Cheat Engine 6.4
	{0x8BC960, {0xc6, 0x05, 0x60, 0xe0, 0x8b, 0x00, 0x00, 0xb9}}, //Cheat Engine 6.5 i386
	{0x433C40, {0xF8, 0x81, 0xA0, 0x00, 0x01, 0x00, 0x00, 0xFF}}, //Cheat Engine 6.5 64bit
	{0x8D97A0, {0xC6, 0x05, 0xB0, 0xB0, 0x8D, 0x00, 0x00, 0xB9}}, //Cheat Engine 6.5.1 i386
	{0x433C40, {0x55, 0x48, 0x89, 0xE5, 0x48, 0x8D, 0x64, 0x24}}, //Cheat Engine 6.5.1 64bit

	{0x433C40, {0xC7, 0x45, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x48}}, //Cheat Engine 6.6
	{0x8F7580, {0xc6, 0x05, 0xc0, 0x91, 0x8f, 0x00, 0x00, 0xb9}}, //Cheat Engine 6.6 i386
	{0x019FD0, {0xc6, 0x05, 0xc0, 0x91, 0x8f, 0x00, 0x00, 0xb9}}, //Cheat Engine 6.6 64bit
	{0x92CAA0, {0xc6, 0x05, 0x00, 0xe2, 0x92, 0x00, 0x00, 0xb9}}, //Cheat Engine 6.7 i386
	{0x433C40, {0x48, 0x8b, 0x45, 0xf8, 0x48, 0x8b, 0x40, 0xe0}}, //Cheat Engine 6.7 64bit

	//Cheat Engine 6.8
	{0x433C40, {0x40, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x55, 0xB8}},	//64bit
	{0x9697C0, {0xC6, 0x05, 0x30, 0xB2, 0x96, 0x00, 0x00, 0xB9}},	//i386
	//Cheat Engine 6.8.1
	{0x432C40, {0x48, 0x8B, 0x45, 0xF8, 0x83, 0xB8, 0xE4, 0x03}},	//64bit
	{0x96A900, {0xC6, 0x05, 0x40, 0xC2, 0x96, 0x00, 0x00, 0xB9}},	//i386
	//Cheat Engine 6.8.2
	{0x432C40, {0xF0, 0x07, 0x00, 0x00, 0x48, 0x8B, 0x45, 0xF8}},	//64bit
	{0x97C920, {0xC6, 0x05, 0x90, 0xE2, 0x97, 0x00, 0x00, 0xB9}},	//i386
	//Cheat Engine 6.8.3
	{0x433C40, {0xF8, 0x48, 0x8B, 0x45, 0xF0, 0x48, 0x8B, 0x55}},	//64bit
	{0x982C90, {0xC6, 0x05, 0x90, 0x42, 0x98, 0x00, 0x00, 0xB9}},	//i386

	//Cheat Engine 7.0
	{0x432C40, {0x00, 0xEB, 0x48, 0x48, 0x8D, 0x8D, 0x80, 0xFE}},	//64bit
	{0x403BA0, {0xC6, 0x05, 0x80, 0xCD, 0x9D, 0x00, 0x00, 0xB9}},	//i386
	//Cheat Engine 7.1
	{0x401790, {0xFF, 0x25, 0x7A, 0xA4, 0xD7, 0x00, 0x00, 0x00}},	//64bit
	{0x403BA0, {0xC6, 0x05, 0xA0, 0xED, 0x9E, 0x00, 0x00, 0xB9}},	//i386

	//Cheat Engine 7.2
	{0x401790, {0xFF, 0x25, 0x7A, 0xC4, 0xDB, 0x00, 0x00, 0x00}},	//64bit
	{0x403BA0, {0xC6, 0x05, 0xC0, 0x7D, 0xA0, 0x00, 0x00, 0xB9}},	//i386

	{0x401704, {0x68, 0x84, 0x24, 0x40, 0x00, 0xE8, 0xEE, 0xFF}}, //MuPie
	{0x401B28, {0x68, 0xD8, 0x2A, 0x40, 0x00, 0xE8, 0xF0, 0xFF}}, //MuPie
	{0x4388C0, {0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x49, 0x4A}}, //Mupie
	{0x4380F0, {0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00}}, //MuPie
	{0x401350, {0xEB, 0x10, 0x66, 0x62, 0x3A, 0x43, 0x2B, 0x2B}}, //WildProxy
	{0x401401, {0xE8, 0xB6, 0xFF, 0xFF, 0xFF, 0x50, 0x50, 0xFF}}, //WildProxy
	{0x4013B0, {0xE8, 0xD7, 0xFF, 0xFF, 0xFF, 0xB9, 0xB4, 0x00}}, //WildProxy
	{0x40133A, {0xA3, 0x8F, 0x20, 0x47, 0x00, 0x52, 0x6A, 0x00}}, //WildProxy
	{0x401320, {0xEB, 0x10, 0x66, 0x62, 0x3A, 0x43, 0x2B, 0x2B}}, //WildProxy
	{0x4013F9, {0xE8, 0x1A, 0x21, 0x06, 0x00, 0xA3, 0x8B, 0x90}}, //WildProxy
	{0x512134, {0x75, 0x05, 0x8A, 0x16, 0x46, 0x12, 0xD2, 0x73}}, //WildProxy
	{0x512014, {0xB8, 0x00, 0x00, 0x00, 0x00, 0x60, 0x0B, 0xC0}}, //WildProxy
	{0x401414, {0xEB, 0x10, 0x66, 0x62, 0x3A, 0x43, 0x2B, 0x2B}}, //WildProxy
	{0x40D6EB, {0xE9, 0x0C, 0x0F, 0x00, 0x00, 0xE8, 0xAF, 0x15}}, //WildProxy
	{0x41D39A, {0xEB, 0x0B, 0x0B, 0xEB, 0x0B, 0x0B, 0xEB, 0x35}}, //SpeederXP
	{0x42FAA4, {0xA7, 0x62, 0x62, 0x62, 0x68, 0x68, 0x68, 0x7B}}, //SpeederXP
	{0x50541A, {0xBE, 0xDE, 0xEE, 0xE2, 0x52, 0xE8, 0x6B, 0xFA}}, //SpeederXP
	{0x42727A, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0xA8, 0x7A}}, //SpeederXP
	{0x5053C8, {0x68, 0x3A, 0x38, 0x21, 0xDB, 0xE8, 0xA9, 0xAB}}, //SpeederXP
	{0x410086, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0x98, 0x3D}}, //Game Speed Changer
	{0x40FBB6, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0x48, 0x3D}}, //Game Speed Changer
	{0x40C0B0, {0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F}}, //Speed Hack Simplifier
	{0x40E04E, {0x53, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x42, 0x65}}, //Speed Hack Simplifier
	{0x402868, {0x52, 0x92, 0x3B, 0x8D, 0xD5, 0x33, 0x78, 0xB7}}, //Speed Hack Simplifier
	{0x417259, {0x89, 0x42, 0xBC, 0xBA, 0x14, 0x00, 0x00, 0x80}}, //Speed Hack
	{0x40134A, {0xA1, 0x8B, 0x50, 0x48, 0x00, 0xC1, 0xE0, 0x02}}, //Speed Hack
	{0x40134F, {0xC1, 0xE0, 0x02, 0xA3, 0x8F, 0x40, 0x47, 0x00}}, //Speed Hack
	{0x401338, {0xEB, 0x10, 0x66, 0x62, 0x3A, 0x43, 0x2B, 0x2B}}, //Speed Hack
	{0x401414, {0x68, 0xA4, 0x22, 0x40, 0x00, 0xE8, 0xEE, 0xFF}}, //Speed Hack
	{0x4217E0, {0x60, 0xBE, 0x00, 0xD0, 0x41, 0x00, 0x8D, 0xBE}}, //!xSpeed.net
	{0x41F04A, {0x8D, 0x5D, 0x5E, 0x53, 0x50, 0xFF, 0x95, 0x49}}, //!xSpeed.net
	{0x401100, {0x33, 0xC0, 0x8B, 0x04, 0x9D, 0x21, 0x79, 0x40}}, //!xSpeed.net
	{0x41D4FE, {0x30, 0xB3, 0x7F, 0x4E, 0xB8, 0x85, 0x54, 0xBC}}, //!xSpeed.net
	{0x41F001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //!xSpeed.net
	{0x4217E0, {0x60, 0xBE, 0x00 ,0xD0, 0x41, 0x00, 0x8D, 0xBE}}, //!xSpeed.net
	{0x420630, {0x60, 0xBE, 0x00, 0xC0, 0x41, 0x00, 0x8D, 0xBE}}, //!xSpeed.net
	{0x420001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //!xSpeed.Pro
	{0x426ECA, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0x90, 0x7A}}, //Speed Gear
	{0x40970E, {0x68, 0xB4, 0x98, 0x40, 0x00, 0x64, 0xA1, 0x00}}, //Speed Gear
	{0x568E9A, {0x68, 0xB8, 0xF9, 0x85, 0x13, 0xE8, 0x9D, 0x53}}, //Speed Gear
	{0x4011D4, {0x68, 0x50, 0x8E, 0x40, 0x00, 0xE8, 0xF0, 0xFF}}, //HackSpeed
	{0x416B41, {0xE8, 0xBC, 0x57, 0x00, 0x00, 0xA3, 0xA4, 0xB2}}, //Game Speed Adjuster
	{0x416AB0, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0xC0, 0xC0}}, //Game Speed Adjuster
	{0x4BCFA4, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xF0, 0x53, 0x56}}, //Xelerator
	{0x430A27, {0xE9, 0x06, 0x01, 0x00, 0x00, 0x3B, 0xD1, 0x72}}, //Speed Wizard
	{0x401027, {0x73, 0xE3, 0xBC, 0x49, 0x73, 0x62, 0x72, 0x4D}}, //Game Acelerator
	{0x492BA6, {0x8D, 0xBE, 0x00, 0xF0, 0xF9, 0xFF, 0xC7, 0x87}}, //D-C SpeedHack
	{0x4DB7C3, {0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68, 0x20, 0x5B}}, //Game Optimizer
	{0x4DD014, {0xB8, 0x00, 0x00, 0x00, 0x00, 0x60, 0x0B, 0xC0}}, //Win Speeder
	{0x401414, {0x68, 0xA4, 0x22, 0x40, 0x00, 0xE8, 0xEE, 0xFF}}, //99.62t Speed Hack
	{0x4C8A60, {0x60, 0xBE, 0x00, 0x00, 0x48, 0x00, 0x8D, 0xBE}}, //Simple Net Speed
	{0x492BDA, {0x75, 0x07, 0x8B, 0x1E, 0x83, 0xEE, 0xFC, 0x11}}, //Agility Hack By TopGun
	{0x48A220, {0x60, 0xBE, 0x00, 0xA0, 0x45, 0x00, 0x8D, 0xBE}}, //MU-SS4 Speed Hack
	{0x43250B, {0xEB, 0x02, 0x33, 0xC0, 0xC2, 0x04, 0x00, 0x83}}, //Game Speeder
	{0x4320F0, {0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00}}, //Cheat Happens
	{0x4340F0, {0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00}}, //Cheat Happens
	{0x4360F0, {0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00}}, //Cheat Happens
	{0x440020, {0x5F, 0xE4, 0xAD, 0x60, 0x36, 0x56, 0x43, 0x4D}}, //Cheat Happens
	{0x4C5F31, {0x7C, 0x23, 0x8B, 0x45, 0xFC, 0x80, 0x38, 0xC1}}, //Catastrophe
	{0x4CDCEC, {0xE8, 0x83, 0x8C, 0xF3, 0xFF, 0x8B, 0x1D, 0x7C}}, //Catastrophe
	{0x4CCB71, {0xA1, 0x40, 0xFD, 0x4C, 0x00, 0x8B, 0x00, 0x8B}}, //Catastrophe
	{0x4CA831, {0x89, 0x55, 0xFC, 0x8B, 0x45, 0xFC, 0xE8, 0xC8}}, //Catastrophe
	{0xB78341, {0x2E, 0x03, 0x00, 0x00, 0xEB, 0x02, 0x83, 0x3D}}, //ArtMoney
	{0x675001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //ArtMoney
	{0x676001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //ArtMoney
	{0x677001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //ArtMoney
	{0x67A001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //ArtMoney
	{0x688001, {0x60, 0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB}}, //ArtMoney
	{0x690002, {0xE8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xEB, 0x04}}, //ArtMoney
	{0x448496, {0xEB, 0x18, 0x3B, 0xC6, 0x0F, 0x83, 0xEA, 0x00}}, //AutoIt
	{0x47A0B8, {0xEB, 0xA6, 0xB6, 0x8A, 0x10, 0x67, 0x83, 0x73}}, //AutoIt
	{0x448D18, {0xEB, 0x18, 0x3B, 0xC6, 0x0F, 0x83, 0xEA, 0x00}}, //AutoIt
	{0x487F97, {0xEB, 0x89, 0xD6, 0x13, 0x95, 0x04, 0x04, 0x03}}, //AutoIt
	{0x448606, {0xEB, 0x18, 0x3B, 0xC6, 0x0F, 0x83, 0xEA, 0x00}}, //AutoIt
	{0x47A1AF, {0xEB, 0x4F, 0xBE, 0x55, 0xBB, 0x65, 0xF3, 0x43}}, //AutoIt
	{0x45016A, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x49910D, {0xEB, 0x07, 0x98, 0x55, 0x60, 0x58, 0x66, 0x56}}, //AutoIt
	{0x450101, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x48C718, {0xEB, 0x83, 0x4D, 0x3F, 0x16, 0x5C, 0x6D, 0x5A}}, //AutoIt
	{0x451E9F, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x498E11, {0xEB, 0xE1, 0x98, 0xE0, 0x95, 0xCD, 0x34, 0x4E}}, //AutoIt
	{0x451AEB, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x48CCE6, {0xEB, 0x6D, 0x01, 0x09, 0x2F, 0x15, 0xDF, 0x25}}, //AutoIt
	{0x4990CA, {0xEB, 0x34, 0x4D, 0xEB, 0x89, 0x0D, 0xD3, 0x01}}, //AutoIt
	{0x48D4B0, {0xEB, 0x5F, 0x04, 0x04, 0x03, 0x83, 0x12, 0x04}}, //AutoIt
	{0x4534AF, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x49B222, {0xEB, 0x75, 0xB5, 0x4C, 0xFB, 0x22, 0x6C, 0xF3}}, //AutoIt
	{0x4530CC, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x48E26C, {0xEB, 0x2D, 0xD4, 0x03, 0x47, 0x6B, 0x1A, 0x47}}, //AutoIt
	{0x4543BF, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x498F1C, {0xEB, 0xDF, 0x11, 0xC1, 0xC2, 0x99, 0x76, 0xC3}}, //AutoIt
	{0x45419A, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x48D4D5, {0xEB, 0x26, 0x1A, 0xC8, 0xDE, 0x84, 0x47, 0x37}}, //AutoIt
	{0x45435F, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x45439F, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x499278, {0xEB, 0x7F, 0x4D, 0xEE, 0xE1, 0x50, 0xD7, 0x66}}, //AutoIt
	{0x45417A, {0xEB, 0x06, 0x3B, 0xC6, 0x7D, 0x07, 0x8B, 0xC6}}, //AutoIt
	{0x48D4D6, {0xEB, 0x84, 0x47, 0x37, 0xC2, 0x8D, 0x89, 0x06}}, //AutoIt
	{0x401DA4, {0xEB, 0xAE, 0x8B, 0x13, 0x8D, 0x04, 0x42, 0xEB}}, //AutoIt
	{0x46A104, {0xE9, 0xE3, 0xDF, 0xFF, 0xFF, 0xBE, 0x5E, 0x00}}, //AutoIt
	{0x12C5B8, {0x75, 0x07, 0x8B, 0x1E, 0x83, 0xEE, 0xFC, 0x11}}, //UoPilot
	{0x4F3590, {0x60, 0xBE, 0x00, 0x10, 0x4A, 0x00, 0x8D, 0xBE}}, //UoPilot
	{0x56C5C6, {0x8D, 0xBE, 0x00, 0x60, 0xF0, 0xFF, 0x57, 0x83}}, //UoPilot
	{0x12C596, {0x8D, 0xBE, 0x00, 0x20, 0xF4, 0xFF, 0xC7, 0x87}}, //UoPilot
	{0x569096, {0x8D, 0xBE, 0x00, 0x70, 0xF0, 0xFF, 0x57, 0x83}}, //UoPilot
	{0x4E5586, {0x8D, 0xBE, 0x00, 0xA0, 0xF6, 0xFF, 0xC7, 0x87}}, //UoPilot
	{0x579646, {0x8D, 0xBE, 0x00, 0xB0, 0xEF, 0xFF, 0x57, 0x83}}, //UoPilot
	{0x44EB02, {0xE8, 0xC5, 0xC0, 0x00, 0x00, 0xE9, 0x78, 0xFE}}, //Process Explorer
	{0xCD3546, {0x6A, 0x1C, 0x89, 0x4C, 0x24, 0x2C, 0x8B, 0xC8}}, //Process Explorer
	{0x40F832, {0x8D, 0x85, 0xF0, 0xFD, 0xFF, 0xFF, 0x50, 0x8D}}, //Hide Toolz
	{0x41155C, {0x55, 0x8B, 0xEC, 0x83, 0xC4, 0xF0, 0xB8, 0x84}}, //Hide Toolz
	{0x48C000, {0xFC, 0xCF, 0xAB, 0xE7, 0x6D, 0x3A, 0x89, 0xBC}}, //Lipsum
	{0x4052BB, {0x00, 0x00, 0x0A, 0x73, 0x90, 0x00, 0x00, 0x0A}}, //Lipsum
	{0x49101F, {0xEA, 0xD3, 0xC6, 0x78, 0x03, 0x79, 0x01, 0x75}}, //Ultimate Cheat
	{0x4A851C, {0x40, 0xAE, 0x80, 0x7C, 0x41, 0xB7, 0x80, 0x7C}}, //Ultimate Cheat
	{0x43FC66, {0xEB, 0xE8, 0x8A, 0x06, 0x46, 0x88, 0x07, 0x47}}, //Mush
	{0x43FC4F, {0x90, 0x61, 0xBE, 0x00, 0x90, 0x43, 0x00, 0x8D}}, //Mush
	{0x534000, {0x8D, 0x8D, 0x51, 0x2E, 0x40, 0x00, 0x50, 0x51}}, //Godlike
	{0x555030, {0x74, 0x37, 0x8D, 0x85, 0xFB, 0x2C, 0x40, 0x00}}, //Godlike
	{0x496CA6, {0x8D, 0xBE, 0x00, 0xC0, 0xF9, 0xFF, 0xC7, 0x87}}, //D-C DupeHack
	{0xAF4014, {0xB8, 0x00, 0x00, 0x00, 0x00, 0x60, 0x0B, 0xC0}}, //FunnyZhyper
	{0x4A47C6, {0xE8, 0xDB, 0xEA, 0x00, 0x00, 0xE9, 0x16, 0xFE}}  //Memory Hacking Software
};

bool SIMAGE_INFO::FINDDLL ( const char* szDLL )
{
	POSITION pos = listModuleFileNameList.GetHeadPosition();
	
	while( pos != NULL )
	{
		Sleep( 1 );
		CString strModule = listModuleFileNameList.GetNext(pos);

		int nIndex = strModule.ReverseFind ( '\\' ) ;
		if ( nIndex==-1 )			continue;

		CString strFILE = strModule.Right ( strModule.GetLength()-nIndex-1 );

		if ( strFILE.CompareNoCase(szDLL)==0 )
		{
			return true;
		}
	}

	return false;
}

std::string SIMAGE_INFO::getinfo ()
{
	std::string strInfo;
	strInfo = strFileName + "/" + strWindowText + "/" + strProductName + "/" + strFileDescription;
	return strInfo;
}

CHPro::CHPro()
{
}

CHPro::~CHPro()
{
	Release();
}

VOID CHPro::Release()
{
	IMAGEMAP_ITER pos = m_mapImage.begin();
	IMAGEMAP_ITER end = m_mapImage.end();
	for( ; pos != end; ++pos )
	{
		delete pos->second; // 이미지 구조체 포인터 삭제
	}
	
	// 맵 클리어. 모든 원소를 제거한다.
	m_mapImage.clear();
}

BOOL CALLBACK EnumWindowsFunc(HWND hWnd, LPARAM lParam) // 윈도우 핸들을 넘겨준다.
{
	if ( !hWnd )	return FALSE;

	DWORD dwID ;
	GetWindowThreadProcessId(hWnd, &dwID); // 핸들을 가지고 프로세스 ID를 얻는다. 
	if( dwID == lParam )
	{
		::GetWindowText(hWnd, szWindowText, sizeof(szWindowText)); // 텍스트를 얻는다.
		return FALSE;
	}
	return TRUE;
}

bool CHPro::CreateProcessUPX(const char * szPathName, CString &strTmpFile )
{
	if ( szPathName == NULL ) return false;
	const char *szPATH = CDebugSet::GetPath();

	//	임시 파일 이름 설정.
	strTmpFile.Format( "%s_image.pak", szPATH );

	//	종전 파일 삭제.
	DeleteFile ( strTmpFile.GetString() );

	//	cmd 명령.
	CString strCMDLine;
	strCMDLine.Format ("\"%s\\extz.exe\" -d \"%s\" -o \"%s\"", SUBPATH::APP_ROOT, szPathName, strTmpFile.GetString() );

	if ( !iswin_nt() )
	{
		//	nt 기반이 아닌 경우. 95, 98, ME
		UINT nRETURN = WinExec( strCMDLine.GetString(), SW_HIDE );
		if ( nRETURN < 31 )		return false;

		Sleep( 600000 );	//	10 분.
	}
	else
	{
		//	nt 기반의 경우. "CREATE_NO_WINDOW" 가 동작함.
		STARTUPINFO si;
		SecureZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.dwFlags = NULL;
		si.wShowWindow = SW_HIDE;

		PROCESS_INFORMATION pi;
		SecureZeroMemory(&pi, sizeof(pi));

		if ( !CreateProcess(
			NULL,					// name of executable module
			strCMDLine.GetBuffer(),	// command line string
			NULL,					// process attributes
			NULL,					// thread attributes
			FALSE,					// handle inheritance option
			CREATE_NO_WINDOW,		// creation flags
			NULL,					// new environment block
			NULL,					// current directory name
			&si,					// startup information
			&pi))					// process information
		{
			strCMDLine.ReleaseBuffer();
			return false;
		} // formation
		strCMDLine.ReleaseBuffer();

		// Wait until child process exits.
		WaitForSingleObject( pi.hProcess, INFINITE );

		// Close process and thread handles. 
		CloseHandle( pi.hProcess );
		CloseHandle( pi.hThread );
	}

	return true;
}

DWORD CHPro::IsMatchStream(const char * szPathName, VECBLOCK& vecBlock)
{
	if ( szPathName == NULL ) return UINT_MAX;

	HANDLE hFile = NULL;
	bool bImage(true); // 압축 풀린 파일의 존재여부

	CString strTmpFile;
	//CreateProcessUPX(szPathName, strTmpFile);
	//{
	//	return UINT_MAX; // UPX 실행 실패
	//}

	hFile = CreateFile(strTmpFile.GetString(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE) 
	{
		hFile = CreateFile(szPathName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		bImage = false;
		if(hFile == INVALID_HANDLE_VALUE) 
		{
			return UINT_MAX; // 파일이 없다면 리턴
		}
	}

	//DWORD dwSize = GetFileSize (hFile, NULL); // 파일 사이즈를 얻는다.
	//if( ( dwSize == INVALID_FILE_SIZE ) || ( dwSize < ( STREAM_OFFSET + STREAM_SIZE ) ) )
	//{
	//	CloseHandle(hFile); // 파일 핸들을 닫는다.
	//	if( bImage )	DeleteFile(strTmpFile.GetString()); // 압축풀린 파일 삭제

	//	return UINT_MAX;
	//}

	// 파일에서 디스크립터를 읽어들인다.
	DWORD dwBytesRead = 0;
	std::vector<BYTE> vecBUFFER;
	vecBUFFER.resize( STREAM_SIZE );

	DWORD dwPtrLow = SetFilePointer(hFile, STREAM_OFFSET, NULL, FILE_BEGIN) ; 

	if (dwPtrLow == INVALID_SET_FILE_POINTER && ( GetLastError() != NO_ERROR ) )
	{ 
		CloseHandle(hFile); // 파일 핸들을 닫는다.
		if( bImage )	DeleteFile(strTmpFile.GetString()); // 압축풀린 파일 삭제

		return UINT_MAX;
	}

	BOOL bResult = ReadFile(hFile, &vecBUFFER[0], STREAM_SIZE, &dwBytesRead, NULL); 
	if ( bResult && !dwBytesRead )
	{
		CloseHandle(hFile); // 파일 핸들을 닫는다.
		if( bImage )	DeleteFile(strTmpFile.GetString()); // 압축풀린 파일 삭제

		return UINT_MAX;
	}

	CloseHandle(hFile); // 파일 핸들을 닫는다.
	if( bImage )	DeleteFile(strTmpFile.GetString()); // 압축풀린 파일 삭제

	DWORD dwSIZE = (DWORD) vecBlock.size();
	for ( DWORD i=0; i<dwSIZE; ++i )
	{
		SBLOCK_INFO & INFO = vecBlock[i];
		if ( INFO.strFileStream=="null" )	continue;

		if( vecBUFFER == INFO.vecFileStream )
		{
			return i;
		}

		//size_t nSIZE = INFO.vecFileStream.size();
		//std::vector<BYTE>::iterator found = std::search ( vecBUFFER.begin(), vecBUFFER.end(), INFO.vecFileStream.begin(), INFO.vecFileStream.end() );
		//if ( found != vecBUFFER.end() )
		//{
		//	return i;
		//}
	}

	return UINT_MAX;
}

DWORD CHPro::DoDETECT_BLOCK ( VECBLOCK& vecBlock, SIMAGE_INFO* pIMAGE )
{
	if ( pIMAGE == NULL ) return UINT_MAX;

	DWORD dwVal = UINT_MAX;
	dwVal = IsMatchStream ( pIMAGE->strPathName.c_str(), vecBlock );
	if ( dwVal != UINT_MAX )
	{
		return dwVal;
	}

	dwVal = UINT_MAX;
	DWORD dwSIZE = (DWORD) vecBlock.size();
	for ( DWORD i=0; i<dwSIZE; ++i )
	{
		Sleep( 1 );

		SBLOCK_INFO & INFO = vecBlock[i];
		if ( !INFO.bVALID )						continue;

		if ( INFO.strName!="null"				&& INFO.strName==pIMAGE->strFileName )						dwVal = i;
		if ( INFO.strProductName!="null"		&& INFO.strProductName==pIMAGE->strProductName )			dwVal = i;
		if ( INFO.strWindowText!="null"			&& INFO.strWindowText==pIMAGE->strWindowText )				dwVal = i;
		if ( INFO.strFileDescription!="null"	&& INFO.strFileDescription==pIMAGE->strFileDescription )	dwVal = i;
		if ( INFO.strLoadDll!="null"			&& pIMAGE->FINDDLL ( INFO.strLoadDll.c_str() ) )			dwVal = i;

		if ( dwVal != UINT_MAX )
		{
			return dwVal;
		}
	}

	return UINT_MAX;
}

/*dmk14 otarapa anti cheat*/
bool CHPro::DumpDetection()
{
	HANDLE hProc = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProc != INVALID_HANDLE_VALUE )
	{
		PROCESSENTRY32 mP32;
		mP32.dwSize = sizeof( mP32 );
		Process32First( hProc, &mP32 );
		
		do 
		{
			HANDLE hProcess = OpenProcess( PROCESS_ALL_ACCESS, false, mP32.th32ProcessID );
			if( hProcess != NULL )
			{
				for( int i = 0; i < ( sizeof(mDumps) / sizeof(HDump) ); i++ ){
					unsigned char pBytes[8];
					__w64 unsigned long pBytesRead;

					if( ReadProcessMemory( hProcess, (LPCVOID)mDumps[i].dwAddress, (LPVOID)pBytes, 8, &pBytesRead ) ){
						if( pBytesRead == 8 ){							
							if( !memcmp( pBytes, mDumps[i].pBytes, 8 ) )
							{
								return true;
							}
						}
					}
				}			
				CloseHandle( hProcess );
			}
		} 
		while( Process32Next( hProc, &mP32 ) );
	}
	CloseHandle( hProc );

	return false;
}

CBLOCK_PROG::VECDETECT CHPro::ProcessDetection(VECBLOCK & vecBlock)
{
	CBLOCK_PROG::VECDETECT vecDETECT;

	HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	
	if (hSnapShot == INVALID_HANDLE_VALUE)		return vecDETECT;

	CSimpleProcessAPI cPROCESS;

	PROCESSENTRY32 pEntry = {0};
	pEntry.dwSize = sizeof(PROCESSENTRY32);

	if(Process32First(hSnapShot, &pEntry))
	{
		do
		{
			Sleep( 1 );

			bool bFlag(true);
			IMAGEMAP_ITER pos = m_mapImage.find( pEntry.th32ProcessID ); // PID를 검색한다.

			if ( pos != m_mapImage.end() ) // PID가 존재 한다면...
			{
				bFlag = false;

				SIMAGE_INFO * imageInfo = pos->second;
				if ( imageInfo->strFileName != pEntry.szExeFile ) // 파일 이름이 다르다면...
				{
					// 기존에 있던 PID를 삭제
					delete pos->second;
					m_mapImage.erase(pos);
					bFlag = true;
				}
			}
			
			if ( bFlag ) // PID가 존재하지 않고 존재하더라도 파일 이름이 다르다면...
			{
				SIMAGE_INFO image_info;

				image_info.strFileName = pEntry.szExeFile; // 구조체에 파일이름 대입

				szWindowText[0] = '\0';
				EnumWindows( (WNDENUMPROC)EnumWindowsFunc, (LPARAM)pEntry.th32ProcessID );

				if( strlen(szWindowText) )
				{
					image_info.strWindowText = szWindowText; // 구조체에 윈도우 텍스트 대입
				}
				
				HANDLE hModuleSnap = CreateToolhelp32Snapshot ( TH32CS_SNAPMODULE, pEntry.th32ProcessID );
				if (hModuleSnap != INVALID_HANDLE_VALUE) 
				{
					bool bFound(false);

					MODULEENTRY32 me32 = {0};
					me32.dwSize = sizeof(MODULEENTRY32);

					if (Module32First(hModuleSnap, &me32)) 
					{ 
						do 
						{
							Sleep( 1 );

							if ( me32.th32ProcessID == pEntry.th32ProcessID ) 
							{ 
								bFound = true;
								break;
							} 
						} 
						while ( !bFound && Module32Next(hModuleSnap, &me32) ); 
					}

					if ( bFound )
					{
						CMiniVersion ver(me32.szExePath);
                        image_info.strPathName = me32.szExePath; // 전체 경로 대입

						_TCHAR szTemp[200] = "";
						ver.GetProductName(szTemp, sizeof(_TCHAR) * 200); // 제품이름을 얻는다.

						if( _tcslen(szTemp) )
							image_info.strProductName = szTemp; // 구조체에 ProductName 대입

						szTemp[0] = '\0';
						ver.GetFileDescription(szTemp, sizeof(_TCHAR) * 200); // 파일 디스트립션을 얻는다.

						if( _tcslen(szTemp) )
							image_info.strFileDescription = szTemp;

						//	이 프로세스가 사용하는 dll 모듈 검출.
						cPROCESS.BuildModuleList ( pEntry.th32ProcessID, image_info.listModuleFileNameList );

						// 각 맵에 삽입
						SIMAGE_INFO *pIMAGE = new SIMAGE_INFO;
						if ( pIMAGE )
						{
							*pIMAGE = image_info;
							m_mapImage.insert( std::make_pair ( pEntry.th32ProcessID, pIMAGE ) );
						}

						DWORD dwDETECT = DoDETECT_BLOCK ( vecBlock, pIMAGE );
						if ( dwDETECT!=UINT_MAX )
						{
							vecDETECT.push_back(CBLOCK_PROG::SDETECT(dwDETECT,false,pIMAGE->getinfo().c_str()));
						}

						ver.Release(); // CMiniVersion 릴리즈
					}
					
					CloseHandle (hModuleSnap);
				}
			}
		}
		while (Process32Next (hSnapShot,&pEntry));
	}
	CloseHandle (hSnapShot);

	return vecDETECT;
}

SIMAGE_INFO * CHPro::GetImageInfo(DWORD dwPID)
{
	IMAGEMAP_ITER pos = m_mapImage.find( dwPID );
	if ( pos != m_mapImage.end() )
		return pos->second;
	else
		return NULL;
}